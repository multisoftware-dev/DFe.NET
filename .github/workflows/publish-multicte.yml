name: multicte-build (build, sync upstream release, upload assets, publish)

on:
  push:
    branches: [multicte-build]
  workflow_dispatch:
    inputs:
      version_suffix:
        description: 'Digits appended to the last version block (HHmm). Example: 001 -> ...HHmm001'
        required: false
        default: ''

permissions:
  contents: write # create/update releases + upload assets
  packages: write # publish to GitHub Packages NuGet
  actions: read

concurrency:
  group: multicte-build
  cancel-in-progress: false

env:
  CONFIGURATION: Release
  NUGET_SOURCE_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json

  # Upstream GitHub repo that defines the canonical releases
  UPSTREAM_REPO: ZeusAutomacao/DFe.NET
  DOTNET_VERSION: 8.0.x

jobs:
  get_upstream:
    name: Get upstream latest release + compute versions
    runs-on: ubuntu-latest

    outputs:
      upstream_tag: ${{ steps.v.outputs.upstream_tag }}
      upstream_version: ${{ steps.v.outputs.upstream_version }}
      nuget_version: ${{ steps.v.outputs.nuget_version }}

    steps:
      - id: v
        uses: actions/github-script@v7
        with:
          script: |
            const upstreamRepo = process.env.UPSTREAM_REPO;
            if (!upstreamRepo || !upstreamRepo.includes("/")) {
              core.setFailed("UPSTREAM_REPO must be set like 'owner/repo'.");
              return;
            }
            const [owner, repo] = upstreamRepo.split("/");

            // suffix comes only from workflow_dispatch input
            const suffixRaw = String(context.payload?.inputs?.version_suffix ?? "").trim();
            const suffixDigits = suffixRaw.replace(/\D+/g, ""); // keep digits only

            const releases = await github.paginate(
              github.rest.repos.listReleases,
              { owner, repo, per_page: 100 }
            );

            const stable = releases.find(r => r.draft === false && r.prerelease === false);
            if (!stable) {
              core.setFailed("No stable upstream release found (non-draft, non-prerelease).");
              return;
            }

            const tag = stable.tag_name;
            if (!tag) {
              core.setFailed("Upstream stable release has no tag_name.");
              return;
            }

            let version = String(tag).trim();
            if (version.startsWith("v")) version = version.substring(1);

            const parts = version.split(".");
            if (parts.length !== 4 || parts.some(p => !/^\d+$/.test(p))) {
              core.setFailed(`Upstream tag '${tag}' is not a 4-part numeric version (yyyy.MM.dd.HHmm).`);
              return;
            }

            const upstreamVersion = parts.join(".");

            // SUFFIX: append digits to last numeric block (HHmm -> HHmmNNN)
            let nugetVersion = upstreamVersion;
            if (suffixDigits.length > 0) {
              parts[3] = parts[3] + suffixDigits;
              nugetVersion = parts.join(".");
            }

            core.setOutput("upstream_tag", tag);
            core.setOutput("upstream_version", upstreamVersion);
            core.setOutput("nuget_version", nugetVersion);

            core.notice(`Upstream tag: ${tag}`);
            core.notice(`Upstream version: ${upstreamVersion}`);
            core.notice(`NuGet version (with optional suffix): ${nugetVersion}`);
  upsert_release:
    name: Create draft / Update existing fork release (suffix-aware)
    runs-on: ubuntu-latest
    needs: [get_upstream]
    outputs:
      exists: ${{ steps.compute.outputs.exists }}
      stored_nuget_version: ${{ steps.compute.outputs.stored_nuget_version }}

    steps:
      - name: Compute release body + marker (single API read path)
        id: compute
        uses: actions/github-script@v7
        with:
          script: |
            const upstreamRepo = process.env.UPSTREAM_REPO;
            if (!upstreamRepo || !upstreamRepo.includes("/")) {
              core.setFailed("UPSTREAM_REPO must be set like 'owner/repo'.");
              return;
            }
            const [upOwner, upRepo] = upstreamRepo.split("/");

            const upstreamTag = `${{ needs.get_upstream.outputs.upstream_tag }}`;
            const upstreamVersion = `${{ needs.get_upstream.outputs.upstream_version }}`;
            const nugetVersion = `${{ needs.get_upstream.outputs.nuget_version }}`;
            const branch = "multicte-build";

            if (!upstreamTag) {
              core.setFailed("Missing upstream_tag.");
              return;
            }

            const markerRe = /<!--\s*multicte-nuget-version:\s*([^\s]+)\s*-->/i;
            const markerLine = `<!-- multicte-nuget-version: ${nugetVersion} -->`;

            async function paginate(method, params) {
              return await github.paginate(method, { ...params, per_page: 100 });
            }
            function isGithubOnly(files) {
              return files.length > 0 && files.every(f => f.startsWith(".github/"));
            }

            // ---- read fork release ONCE (if exists)
            let forkRelease = null;
            try {
              const rel = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: upstreamTag
              });
              forkRelease = rel.data;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            const exists = !!forkRelease;
            core.setOutput("exists", exists ? "true" : "false");

            const existingBody = forkRelease?.body ?? "";
            const m = existingBody.match(markerRe);
            core.setOutput("stored_nuget_version", m ? m[1] : "");

            // ---- CASE A: missing release => build upstream notes
            if (!exists) {
              const releases = await paginate(github.rest.repos.listReleases, { owner: upOwner, repo: upRepo });
              const idx = releases.findIndex(r => r.tag_name === upstreamTag);
              if (idx === -1) {
                core.setFailed(`Could not find upstream tag '${upstreamTag}' in upstream releases list.`);
                return;
              }
              const prev = releases[idx + 1];
              const prevTag = prev?.tag_name ?? null;

              let commits = [];
              if (prevTag) {
                const cmp = await github.rest.repos.compareCommits({ owner: upOwner, repo: upRepo, base: prevTag, head: upstreamTag });
                commits = cmp.data.commits ?? [];
              } else {
                const tagRef = await github.rest.git.getRef({ owner: upOwner, repo: upRepo, ref: `tags/${upstreamTag}` });
                const list = await github.rest.repos.listCommits({ owner: upOwner, repo: upRepo, sha: tagRef.data.object.sha, per_page: 50 });
                commits = list.data ?? [];
              }

              const prMap = new Map();
              const commitSummaries = [];
              for (const c of commits) {
                const sha = c.sha;
                const msg = (c.commit?.message ?? "").split("\n")[0] || "(no message)";
                commitSummaries.push({ sha, msg });

                try {
                  const prs = await github.request(
                    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
                    { owner: upOwner, repo: upRepo, commit_sha: sha, headers: { accept: "application/vnd.github+json" } }
                  );
                  for (const pr of (prs.data ?? [])) {
                    if (!prMap.has(pr.number)) prMap.set(pr.number, pr);
                  }
                } catch {}
              }

              const prs = Array.from(prMap.values()).sort((a,b) => a.number - b.number);

              const lines = [];
              lines.push(`# Upstream release ${upstreamTag}`);
              if (prevTag) lines.push(`**Changes since:** ${prevTag}`);
              lines.push("");
              lines.push(`## Pull requests (${prs.length})`);
              if (prs.length === 0) {
                lines.push("_No associated PRs found._");
              } else {
                for (const pr of prs) {
                  const user = pr.user?.login ? `@${pr.user.login}` : "";
                  lines.push(`- [#${pr.number}](${pr.html_url}) ${pr.title} ${user}`.trim());
                }
              }
              lines.push("");
              const MAX_COMMITS = 200;
              lines.push(`## Commits (${Math.min(commitSummaries.length, MAX_COMMITS)}${commitSummaries.length > MAX_COMMITS ? "+" : ""})`);
              for (const c of commitSummaries.slice(0, MAX_COMMITS)) {
                const short = c.sha.substring(0,7);
                lines.push(`- \`${short}\` ${c.msg}`);
              }
              if (commitSummaries.length > MAX_COMMITS) lines.push(`\n_Commit list truncated at ${MAX_COMMITS} entries._`);
              lines.push("");
              lines.push(markerLine);

              core.setOutput("release_body", lines.join("\n"));
              return;
            }

            // ---- CASE B: release exists => optionally append delta
            let body = existingBody;

            // always keep marker in sync (or add it)
            body = body.replace(markerRe, markerLine);
            if (!markerRe.test(body)) body = `${body}\n\n${markerLine}`;

            // only do delta logic when nugetVersion != upstreamVersion
            if (nugetVersion !== upstreamVersion) {
              const tagRef = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${upstreamTag}`
              });
              const tagSha = tagRef.data.object.sha;

              const br = await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch
              });
              const headSha = br.data.commit.sha;

              const cmpFork = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: tagSha,
                head: headSha
              });

              const commitsFork = cmpFork.data.commits ?? [];
              const kept = [];

              for (const c of commitsFork.slice(0, MAX)) {
                const full = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: c.sha
                });

                const files = (full.data.files ?? []).map(f => f.filename);
                if (files.length === 0) { kept.push(c); continue; }
                if (!isGithubOnly(files)) kept.push(c);
              }

              if (kept.length > 0) {
                const delta = [];
                delta.push(`## MultiCTe rebuild ${nugetVersion}`);
                delta.push("");
                delta.push(`Commits after fork release \`${upstreamTag}\` on \`${branch}\` (excluding \`.github/**\` only commits):`);
                delta.push("");
                for (const c of kept) {
                  const short = c.sha.substring(0,7);
                  const msg = (c.commit?.message ?? "").split("\n")[0] || "(no message)";
                  const url = `https://github.com/${context.repo.owner}/${context.repo.repo}/commit/${c.sha}`;
                  delta.push(`- [\`${short}\`](${url}) ${msg}`);
                }
                delta.push("");
                body = `${body}\n\n${delta.join("\n")}`;
              }
            }

            core.setOutput("release_body", body.trim() + "\n");

      - name: Create draft release (only if missing)
        if: ${{ steps.compute.outputs.exists != 'true' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.get_upstream.outputs.upstream_tag }}
          name: ${{ needs.get_upstream.outputs.upstream_tag }}
          body: ${{ steps.compute.outputs.release_body }}
          draft: true
          allowUpdates: false
      - name: Update release body (only if exists)
        if: ${{ steps.compute.outputs.exists == 'true' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.get_upstream.outputs.upstream_tag }}
          name: ${{ needs.get_upstream.outputs.upstream_tag }}
          body: ${{ steps.compute.outputs.release_body }}
          allowUpdates: true
          omitBodyDuringUpdate: false

  build_required_projects:
    name: Build required projects (Windows 2022)
    runs-on: windows-2022
    needs: [get_upstream, upsert_release]
    # Run only when we are rebuilding (suffix differs from upstream OR differs from last stored nuget_version)
    # You already compute this condition in prior jobs; wire it here.
    # Example condition (adapt to your real outputs):
    if: >-
      ${{ needs.get_upstream.outputs.nuget_version != needs.get_upstream.outputs.upstream_version ||
      needs.get_upstream.outputs.nuget_version != needs.upsert_release.outputs.stored_nuget_version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Versao
        shell: pwsh
        run: echo "${{ needs.get_upstream.outputs.nuget_version }}"

      - name: Setup .NET 8.0.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
          cache: true
          cache-dependency-path: |
            **/*.csproj
            **/*.props
            **/*.targets

      # - name: Install .NET Framework dev packs (net472, net48)
      #   shell: pwsh
      #   run: |
      #     choco install netfx-4.7.2-devpack netfx-4.8-devpack -y --no-progress

      # --------------------
      # RESTORE (explicit)
      # --------------------
      - name: Restore Base
        shell: pwsh
        run: |
          dotnet restore ".\DFe.Classes\DFe.Classes.csproj"
          dotnet restore ".\DFe.Utils\DFe.Utils.csproj"
          dotnet restore ".\DFe.Wsdl\DFe.Wsdl.csproj"

      - name: Restore NFe
        shell: pwsh
        run: |
          dotnet restore ".\NFe.Classes\NFe.Classes.csproj"
          dotnet restore ".\NFe.Servicos\NFe.Servicos.csproj"
          dotnet restore ".\NFe.Utils\NFe.Utils.csproj"
          dotnet restore ".\NFe.Wsdl\NFe.Wsdl.csproj"
          dotnet restore ".\NFe.Wsdl.Standard\NFe.Wsdl.Standard.csproj"

      - name: Restore Danfe
        shell: pwsh
        run: |
          dotnet restore ".\NFe.Danfe.Base\NFe.Danfe.Base.csproj"
          dotnet restore ".\NFe.Danfe.Nativo\NFe.Danfe.Nativo.csproj"
          dotnet restore ".\NFe.Danfe.OpenFast\NFe.Danfe.OpenFast.csproj"

      - name: Restore nuspec projects
        shell: pwsh
        run: |
          dotnet restore ".\NuGet-MultiCTe\MultiCTe.Zeus.NFe\MultiCTe.Zeus.NFe.csproj"
          dotnet restore ".\NuGet-MultiCTe\MultiCTe.Zeus.Danfe.Nativo\MultiCTe.Zeus.Danfe.Nativo.csproj"
          dotnet restore ".\NuGet-MultiCTe\MultiCTe.Zeus.Danfe.OpenFast\MultiCTe.Zeus.Danfe.OpenFast.csproj"

      # --------------------
      # BUILD (no restore)
      # --------------------
      - name: Build Base
        shell: pwsh
        run: |
          $v = "${{ needs.get_upstream.outputs.nuget_version }}"
          dotnet build -c Release --no-restore -p:Version=$v ".\DFe.Classes\DFe.Classes.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\DFe.Utils\DFe.Utils.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\DFe.Wsdl\DFe.Wsdl.csproj"

      - name: Build NFe
        shell: pwsh
        run: |
          $v = "${{ needs.get_upstream.outputs.nuget_version }}"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Classes\NFe.Classes.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Servicos\NFe.Servicos.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Utils\NFe.Utils.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Wsdl\NFe.Wsdl.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Wsdl.Standard\NFe.Wsdl.Standard.csproj"

      - name: Build Danfe
        shell: pwsh
        run: |
          $v = "${{ needs.get_upstream.outputs.nuget_version }}"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Danfe.Base\NFe.Danfe.Base.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Danfe.Nativo\NFe.Danfe.Nativo.csproj"
          dotnet build -c Release --no-restore -p:Version=$v ".\NFe.Danfe.OpenFast\NFe.Danfe.OpenFast.csproj"
      - name: Pack (dotnet pack via NuspecFile wrappers)
        shell: pwsh
        run: |
          $v = "${{ needs.get_upstream.outputs.nuget_version }}"
          New-Item -ItemType Directory -Force -Path ".\out\packages" | Out-Null

          dotnet pack -c Release --no-build -p:NuspecProperties=version=$v -p:PackageVersion=$v -o .\out\packages ".\NuGet-MultiCTe\MultiCTe.Zeus.NFe\MultiCTe.Zeus.NFe.csproj"
          dotnet pack -c Release --no-build -p:NuspecProperties=version=$v -p:PackageVersion=$v -o .\out\packages ".\NuGet-MultiCTe\MultiCTe.Zeus.Danfe.Nativo\MultiCTe.Zeus.Danfe.Nativo.csproj"
          dotnet pack -c Release --no-build -p:NuspecProperties=version=$v -p:PackageVersion=$v -o .\out\packages ".\NuGet-MultiCTe\MultiCTe.Zeus.Danfe.OpenFast\MultiCTe.Zeus.Danfe.OpenFast.csproj"

      - name: Collect release assets (nupkg + referenced dlls from nuspec; dlls grouped by name/tfm)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $assets = Join-Path $PWD "out\release-assets"
          New-Item -ItemType Directory -Force -Path $assets | Out-Null

          # 1) Collect nupkgs
          Get-ChildItem -Path ".\out\packages" -Filter *.nupkg | ForEach-Object {
            Copy-Item -Force $_.FullName -Destination $assets
          }

          function Get-TfmFromPath([string]$p) {
            # Typical layout: ...\bin\Release\<tfm>\X.dll  OR ...\bin\Release\<tfm>\publish\X.dll
            $norm = $p -replace '/', '\'
            $m = [regex]::Match($norm, '\\bin\\Release\\([^\\]+)\\')
            if ($m.Success) { return $m.Groups[1].Value }
            return "unknown"
          }

          # 2) Collect DLLs referenced by nuspec <files><file src="..."> into:
          #    <assets>\<dll-name-without-ext>\<tfm>\<full-dll-name>
          $nuspecs = @(
            "NuGet-MultiCTe\MultiCTe.Zeus.NFe\MultiCTe.Zeus.NFe.nuspec",
            "NuGet-MultiCTe\MultiCTe.Zeus.Danfe.Nativo\MultiCTe.Zeus.Danfe.Nativo.nuspec",
            "NuGet-MultiCTe\MultiCTe.Zeus.Danfe.OpenFast\MultiCTe.Zeus.Danfe.OpenFast.nuspec"
          )

          foreach ($ns in $nuspecs) {
            if (-not (Test-Path $ns)) { throw "Missing nuspec: $ns" }

            $nsDir = Split-Path -Parent (Resolve-Path $ns)

            [xml]$x = Get-Content $ns -Raw
            $nsm = New-Object System.Xml.XmlNamespaceManager($x.NameTable)
            if ($x.DocumentElement.NamespaceURI) {
              $nsm.AddNamespace("n", $x.DocumentElement.NamespaceURI)
            }

            $nodes = @()
            if ($x.DocumentElement.NamespaceURI) {
              $nodes = $x.SelectNodes("//n:files/n:file", $nsm)
            }
            if (-not $nodes -or $nodes.Count -eq 0) {
              $nodes = $x.SelectNodes("//files/file") # fallback (no namespace)
            }

            foreach ($node in $nodes) {
              $src = $node.GetAttribute("src")
              if ([string]::IsNullOrWhiteSpace($src)) { continue }

              # Expand wildcards relative to nuspec folder
              $pattern = Join-Path $nsDir $src
              $matches = Get-ChildItem -Path $pattern -File -ErrorAction Stop

              foreach ($m in $matches) {
                if (-not $m.FullName.ToLower().EndsWith(".dll")) { continue }

                $dllName = $m.Name
                $dllBase = [IO.Path]::GetFileNameWithoutExtension($dllName)
                $tfm = Get-TfmFromPath $m.FullName

                $destDir = Join-Path $assets (Join-Path $dllBase (Join-Path $tfm ""))
                New-Item -ItemType Directory -Force -Path $destDir | Out-Null

                Copy-Item -Force $m.FullName -Destination (Join-Path $destDir $dllName)
              }
            }
          }

          Write-Host "Assets collected:"
          Get-ChildItem $assets -Recurse -File | ForEach-Object { Write-Host " - $($_.FullName.Replace($assets,'').TrimStart('\'))" }

      - name: Upload build artifacts for release upload
        uses: actions/upload-artifact@v4
        with:
          name: release-assets
          path: out/release-assets/*
          if-no-files-found: error

  upload_assets_to_release:
    name: Upload assets to GitHub Release
    runs-on: ubuntu-latest
    needs: [get_upstream, upsert_release, build_required_projects] # adjust to your actual job ids
    permissions:
      contents: write

    steps:
      - name: Download release assets artifact
        uses: actions/download-artifact@v4
        with:
          name: release-assets
          path: release-assets

      - name: Create one zip per folder (preserve structure)
        shell: bash
        run: |
          set -euo pipefail

          cd release-assets

          # zip each top-level directory: <dir>.zip
          for d in */ ; do
            d="${d%/}"
            [ -d "$d" ] || continue
            echo "Zipping $d -> ${d}.zip"
            (cd "$d" && zip -r "../${d}.zip" .)
          done

          ls -la *.zip || true

      - name: Upload assets to release (replace existing)
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.get_upstream.outputs.upstream_tag }}
          allowUpdates: true
          omitBodyDuringUpdate: true
          artifacts: |
            release-assets/*.nupkg
            release-assets/*.zip
          artifactErrorsFailBuild: true
          replacesArtifacts: true

  publish_packages_and_release:
    name: Push nupkgs to GitHub Packages + (optional) publish release
    runs-on: ubuntu-latest
    needs:
      - get_upstream
      - upsert_release
      - build_required_projects
      - upload_assets_to_release
    permissions:
      packages: write
      contents: write

    # Only publish when we are rebuilding:
    # - nuget_version != upstream_version (suffix used), OR
    # - nuget_version != stored_nuget_version (e.g., 001 -> 002)
    # Wire stored_nuget_version from your release-body marker check job.
    #
    if: >-
      ${{ needs.get_upstream.outputs.nuget_version != needs.get_upstream.outputs.upstream_version ||
      needs.get_upstream.outputs.nuget_version != needs.upsert_release.outputs.stored_nuget_version }}

    steps:
      - name: Download release assets (nupkgs)
        uses: actions/download-artifact@v4
        with:
          name: release-assets
          path: release-assets

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          source-url: ${{ env.NUGET_SOURCE_URL }}
          dotnet-version: ${{ env.DOTNET_VERSION }}
        env:
          NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Push nupkgs to GitHub Packages
        shell: pwsh
        run: |
          dotnet nuget push "release-assets/*.nupkg" `
          --source "${{ env.NUGET_SOURCE_URL }}" `
          --api-key "${{ secrets.GITHUB_TOKEN }}" `
          --skip-duplicate

      # Optional: publish the GitHub Release (draft -> published)
      # This is safe to run even if it is already published.
      - name: Publish the GitHub Release (draft -> published)
        if: success()
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.get_upstream.outputs.upstream_tag }}
          draft: false
          allowUpdates: true
          omitBodyDuringUpdate: true
