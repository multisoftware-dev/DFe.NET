name: multicte-build (build, sync upstream release, upload assets, publish)

on:
  push:
    branches: [multicte-build]
  workflow_dispatch:
    inputs:
      path:
        description: 'Digits appended to the last version block (HHmm). Example: 001 -> ...HHmm001'
        required: false
        default: ''

permissions:
  contents: write # create/update releases + upload assets
  packages: write # publish to GitHub Packages NuGet
  actions: read

env:
  CONFIGURATION: Release

  # Upstream GitHub repo that defines the canonical releases
  UPSTREAM_REPO: ZeusAutomacao/DFe.NET

  # Nuspecs that you want to pack
  NUSPECS: |
    NuGet-MultiCTe/specs/MultiCTe.Zeus.NFe.nuspec
    NuGet-MultiCTe/specs/MultiCTe.Zeus.Danfe.OpenFast.nuspec
    NuGet-MultiCTe/specs/MultiCTe.Zeus.Danfe.Nativo.nuspec

jobs:
  versioning:
    name: Get upstream latest release + compute version
    runs-on: ubuntu-latest

    # expose outputs to other jobs via needs.get_upstream_release.outputs.*
    outputs:
      upstream_tag: ${{ steps.upstream.outputs.upstream_tag }}
      upstream_version: ${{ steps.upstream.outputs.upstream_version }}
      final_version: ${{ steps.upstream.outputs.final_version }}

    steps:
      - name: Fetch upstream latest release (JS)
        id: upstream
        uses: actions/github-script@v7
        with:
          script: |
            // CONFIG
            const upstreamRepo = process.env.UPSTREAM_REPO; // e.g. "ZeusAutomacao/DFe.NET"
            if (!upstreamRepo || !upstreamRepo.includes("/")) {
              core.setFailed("UPSTREAM_REPO must be set like 'owner/repo'.");
              return;
            }
            const [owner, repo] = upstreamRepo.split("/");

            // Optional "path" input (only exists on workflow_dispatch runs)
            // We'll append digits from it to the *last numeric block* of the version.
            const rawPath = (context.payload?.inputs?.path ?? "").trim();

            // Fetch latest upstream release
            const rel = await github.rest.repos.getLatestRelease({ owner, repo });
            const tag = rel.data.tag_name;

            if (!tag) {
              core.setFailed("Upstream latest release has no tag_name.");
              return;
            }

            // Upstream uses yyyy.MM.dd.HHmm (4 blocks). Strip leading "v" if present.
            let baseVersion = String(tag).trim();
            if (baseVersion.startsWith("v")) baseVersion = baseVersion.substring(1);

            const parts = baseVersion.split(".");
            if (parts.length !== 4 || parts.some(p => !/^\d+$/.test(p))) {
              core.setFailed(`Upstream tag '${tag}' is not a 4-part numeric version (yyyy.MM.dd.HHmm).`);
              return;
            }

            let finalVersion = baseVersion;

            // Append only digits from "path" to the last block
            // Example: base 2026.01.19.1935 + path "001" => 2026.01.19.1935001
            // If path contains non-digits, we strip them.
            const suffixDigits = rawPath.replace(/\D+/g, "");
            if (suffixDigits.length > 0) {
              parts[3] = parts[3] + suffixDigits;
              finalVersion = parts.join(".");
            }

            core.setOutput("upstream_tag", tag);
            core.setOutput("upstream_version", baseVersion);
            core.setOutput("final_version", finalVersion);
  release_notes:
    name: Build release body (PRs + commits) from upstream
    runs-on: ubuntu-latest
    needs: [versioning]

    outputs:
      release_body_md: ${{ steps.notes.outputs.release_body_md }}

    steps:
      - name: Build markdown release notes (JS)
        id: notes
        uses: actions/github-script@v7
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }} # keep the same env you set at workflow-level
        with:
          script: |
            const upstreamRepo = process.env.UPSTREAM_REPO;
            if (!upstreamRepo || !upstreamRepo.includes("/")) {
              core.setFailed("UPSTREAM_REPO must be set like 'owner/repo'.");
              return;
            }
            const [owner, repo] = upstreamRepo.split("/");

            const currentTag = `${{ needs.versioning.outputs.upstream_tag }}`;
            if (!currentTag) {
              core.setFailed("Missing upstream_tag from previous job.");
              return;
            }

            // Helper: paginate
            async function paginate(method, params) {
              return await github.paginate(method, { ...params, per_page: 100 });
            }

            // 1) Find the previous release tag (older than currentTag)
            const releases = await paginate(github.rest.repos.listReleases, { owner, repo });
            const idx = releases.findIndex(r => r.tag_name === currentTag);
            if (idx === -1) {
              core.setFailed(`Could not find current tag '${currentTag}' in upstream releases list.`);
              return;
            }
            const prev = releases[idx + 1]; // listReleases returns newest-first
            const previousTag = prev?.tag_name ?? null;

            // 2) Collect commits in the range (previousTag..currentTag) if previousTag exists.
            // If this is the first release, we’ll just list commits pointed by the tag’s commit (limited).
            let commits = [];
            if (previousTag) {
              const cmp = await github.rest.repos.compareCommits({
                owner, repo,
                base: previousTag,
                head: currentTag
              });

              // compareCommits returns up to 250 commits depending on API; for huge ranges, this is limited.
              commits = cmp.data.commits ?? [];
            } else {
              // Fallback: list commits from the tag commit (shallow, best-effort)
              const tagRef = await github.rest.git.getRef({ owner, repo, ref: `tags/${currentTag}` });
              const tagSha = tagRef.data.object.sha;

              const list = await github.rest.repos.listCommits({
                owner, repo,
                sha: tagSha,
                per_page: 50
              });
              commits = list.data ?? [];
            }

            // 3) For each commit, try to find associated PR(s)
            // This endpoint requires the "groot-preview" header historically; GitHub now generally supports it,
            // but we'll include it defensively.
            const prMap = new Map(); // key: PR number, value: pr object
            const commitSummaries = [];

            for (const c of commits) {
              const sha = c.sha;
              const msg = (c.commit?.message ?? "").split("\n")[0] || "(no message)";
              commitSummaries.push({ sha, msg, author: c.commit?.author?.name ?? null });

              try {
                const prs = await github.request(
                  "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
                  {
                    owner, repo,
                    commit_sha: sha,
                    headers: { accept: "application/vnd.github+json" }
                  }
                );

                for (const pr of (prs.data ?? [])) {
                  if (!prMap.has(pr.number)) prMap.set(pr.number, pr);
                }
              } catch (e) {
                // Not fatal: not every commit is associated with a PR (direct pushes, merge commits, etc.)
              }
            }

            const prs = Array.from(prMap.values())
              .sort((a, b) => a.number - b.number);

            // 4) Build markdown
            const lines = [];
            lines.push(`# Upstream release ${currentTag}`);
            if (previousTag) lines.push(`**Changes since:** ${previousTag}`);
            lines.push("");

            // PR section
            lines.push(`## Pull requests (${prs.length})`);
            if (prs.length === 0) {
              lines.push("_No associated PRs found (may be direct commits or squash merges without association)._");
            } else {
              for (const pr of prs) {
                const title = (pr.title ?? "").trim();
                const number = pr.number;
                const url = pr.html_url;
                const user = pr.user?.login ? `@${pr.user.login}` : "";
                lines.push(`- [#${number}](${url}) ${title} ${user}`.trim());
              }
            }
            lines.push("");

            // Commits section (limit to keep release notes readable)
            const MAX_COMMITS = 200;
            lines.push(`## Commits (${Math.min(commitSummaries.length, MAX_COMMITS)}${commitSummaries.length > MAX_COMMITS ? "+" : ""})`);
            const shown = commitSummaries.slice(0, MAX_COMMITS);
            for (const c of shown) {
              const shortSha = c.sha.substring(0, 7);
              const author = c.author ? ` (${c.author})` : "";
              lines.push(`- \`${shortSha}\` ${c.msg}${author}`);
            }
            if (commitSummaries.length > MAX_COMMITS) {
              lines.push("");
              lines.push(`_Commit list truncated at ${MAX_COMMITS} entries._`);
            }

            // 5) Output (as a single string)
            const body = lines.join("\n");
            core.setOutput("release_body_md", body);
  # build_and_pack_windows:
  #   name: Build + Pack (Windows)
  #   runs-on: windows-2022
  #   outputs:
  #     # "raw" version == upstream tag
  #     upstream_version: ${{ steps.versions.outputs.upstream_version }}
  #     # publish version is suffixed so NuGet feed can accept it
  #     publish_version: ${{ steps.versions.outputs.publish_version }}
  #   steps:
  #     - name: Install .NET Framework targeting packs
  #       shell: pwsh
  #       run: |
  #         choco install netfx-4.7.2-devpack -y
  #         choco install netfx-4.8-devpack -y

  #     - name: Checkout
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Setup .NET
  #       uses: actions/setup-dotnet@v4
  #       with:
  #         dotnet-version: |
  #           8.0.x

  #     - name: Setup NuGet.exe
  #       uses: NuGet/setup-nuget@v2

  #     - name: Restore + Build (auto-detect .sln)
  #       shell: pwsh
  #       run: |
  #         $ErrorActionPreference = "Stop"
  #         $sln = Get-ChildItem -Path . -Filter *.sln -Recurse | Select-Object -First 1
  #         if (-not $sln) { throw "No .sln found in repo. Add one or hardcode the solution path in the workflow." }

  #         dotnet restore $sln.FullName
  #         dotnet build   $sln.FullName -c $env:CONFIGURATION --no-restore

  #     - name: Pack nuspecs (raw upstream version) + collect referenced DLLs
  #       id: pack
  #       shell: pwsh
  #       run: |
  #         $ErrorActionPreference = "Stop"

  #         $outRoot = Join-Path $PWD "out"
  #         $pkgDir  = Join-Path $outRoot "packages-raw"
  #         $dllDir  = Join-Path $outRoot "dlls"
  #         New-Item -ItemType Directory -Force -Path $pkgDir, $dllDir | Out-Null

  #         $version = "${{ steps.versions.outputs.upstream_version }}"

  #         $nuspecs = @()
  #         "${{ env.NUSPECS }}" -split "`n" | ForEach-Object {
  #           $p = $_.Trim()
  #           if ($p) { $nuspecs += $p }
  #         }

  #         foreach ($ns in $nuspecs) {
  #           if (-not (Test-Path $ns)) { throw "Nuspec not found: $ns" }

  #           Write-Host "Packing: $ns (version=$version)"
  #           nuget pack $ns -Version $version -Properties "Configuration=$env:CONFIGURATION" -OutputDirectory $pkgDir -NonInteractive

  #           # Collect DLLs listed in <files><file src="...dll" .../>
  #           [xml]$x = Get-Content $ns -Raw
  #           $nsm = New-Object System.Xml.XmlNamespaceManager($x.NameTable)
  #           $nsm.AddNamespace("n", $x.DocumentElement.NamespaceURI)

  #           $fileNodes = $x.SelectNodes("//n:files/n:file", $nsm)
  #           foreach ($node in $fileNodes) {
  #             $src = $node.GetAttribute("src")
  #             if ([string]::IsNullOrWhiteSpace($src)) { continue }

  #             # nuspec src paths are relative to nuspec file
  #             $nsDir = Split-Path -Parent (Resolve-Path $ns)
  #             $full  = Resolve-Path (Join-Path $nsDir $src) -ErrorAction Stop

  #             if ($full.Path.ToLower().EndsWith(".dll")) {
  #               Copy-Item -Force $full.Path -Destination $dllDir
  #             }
  #           }
  #         }

  #         Write-Host "Packed nupkgs:"
  #         Get-ChildItem $pkgDir -Filter *.nupkg | ForEach-Object { Write-Host " - $($_.FullName)" }

  #         Write-Host "Collected dlls:"
  #         Get-ChildItem $dllDir -Filter *.dll | ForEach-Object { Write-Host " - $($_.FullName)" }

  #     - name: Pack nuspecs (publish version with suffix) for GitHub Packages
  #       shell: pwsh
  #       run: |
  #         $ErrorActionPreference = "Stop"

  #         $outRoot = Join-Path $PWD "out"
  #         $pkgDir  = Join-Path $outRoot "packages-publish"
  #         New-Item -ItemType Directory -Force -Path $pkgDir | Out-Null

  #         $version = "${{ steps.versions.outputs.publish_version }}"

  #         $nuspecs = @()
  #         "${{ env.NUSPECS }}" -split "`n" | ForEach-Object {
  #           $p = $_.Trim()
  #           if ($p) { $nuspecs += $p }
  #         }

  #         foreach ($ns in $nuspecs) {
  #           Write-Host "Packing (publish): $ns (version=$version)"
  #           nuget pack $ns -Version $version -Properties "Configuration=$env:CONFIGURATION" -OutputDirectory $pkgDir -NonInteractive
  #         }

  #     - name: Upload artifacts (raw packages + dlls + publish packages)
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: build-output
  #         path: |
  #           out/packages-raw/*.nupkg
  #           out/packages-publish/*.nupkg
  #           out/dlls/*.dll
  #         if-no-files-found: error

  # sync_release_and_upload_assets:
  #   name: Create/update fork release + upload assets (from upstream body)
  #   runs-on: ubuntu-latest
  #   needs: [build_and_pack_windows]
  #   steps:
  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: build-output
  #         path: out

  #     - name: Fetch upstream latest release info (tag + body)
  #       id: upstream
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         set -euo pipefail
  #         r="$(gh api "repos/${UPSTREAM_REPO}/releases/latest")"
  #         tag="$(printf '%s' "$r" | jq -r '.tag_name')"
  #         body="$(printf '%s' "$r" | jq -r '.body // ""')"
  #         if [ -z "$tag" ] || [ "$tag" = "null" ]; then
  #           echo "Upstream latest release has no tag_name." >&2
  #           exit 1
  #         fi

  #         echo "tag=$tag" >> "$GITHUB_OUTPUT"

  #         # Save body for release creation
  #         mkdir -p meta
  #         printf '%s' "$body" > meta/upstream-body.md

  #     - name: Create release in fork if missing (keep upstream body)
  #       id: release
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         set -euo pipefail
  #         tag="${{ steps.upstream.outputs.tag }}"

  #         if gh release view "$tag" >/dev/null 2>&1; then
  #           echo "exists=true" >> "$GITHUB_OUTPUT"
  #           echo "Release already exists: $tag"
  #         else
  #           echo "exists=false" >> "$GITHUB_OUTPUT"
  #           echo "Creating release: $tag"

  #           # Create tag implicitly via release creation.
  #           # We attach upstream body.
  #           gh release create "$tag" \
  #             --title "$tag" \
  #             --notes-file meta/upstream-body.md \
  #             --latest
  #         fi

  #     - name: Upload/replace assets (raw nupkgs + dlls) to fork release
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         set -euo pipefail
  #         tag="${{ steps.upstream.outputs.tag }}"

  #         # Replace assets if already present
  #         shopt -s nullglob
  #         assets=( out/packages-raw/*.nupkg out/dlls/*.dll )
  #         if [ ${#assets[@]} -eq 0 ]; then
  #           echo "No assets found to upload." >&2
  #           exit 1
  #         fi

  #         gh release upload "$tag" "${assets[@]}" --clobber

  # publish_github_packages:
  #   name: Publish nupkgs to GitHub Packages
  #   runs-on: windows-latest
  #   needs: [build_and_pack_windows]
  #   steps:
  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: build-output
  #         path: out

  #     - name: Setup .NET
  #       uses: actions/setup-dotnet@v4
  #       with:
  #         dotnet-version: |
  #           8.0.x

  #     - name: Add GitHub Packages NuGet source
  #       shell: pwsh
  #       run: |
  #         $ErrorActionPreference = "Stop"
  #         $owner = "${{ github.repository_owner }}"
  #         dotnet nuget remove source github 2>$null | Out-Null
  #         dotnet nuget add source "https://nuget.pkg.github.com/$owner/index.json" `
  #           --name github `
  #           --username "$owner" `
  #           --password "${{ secrets.GITHUB_TOKEN }}" `
  #           --store-password-in-clear-text

  #     - name: Push publish packages (suffix version)
  #       shell: pwsh
  #       run: |
  #         $ErrorActionPreference = "Stop"
  #         $pkgs = Get-ChildItem -Path out\packages-publish -Filter *.nupkg
  #         if (-not $pkgs) { throw "No publish packages found." }

  #         foreach ($p in $pkgs) {
  #           Write-Host "Pushing $($p.FullName)"
  #           dotnet nuget push $p.FullName --source github --skip-duplicate
  #         }
